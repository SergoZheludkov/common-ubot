# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type DeleteManyResponse {
    "The number of records deleted."
    deletedCount: Int!
}

type Mutation {
    createManyUsers(input: CreateManyUsersInput!): [User!]!
    createOneUser(input: CreateOneUserInput!): User!
    createUser(input: UserCreate!): User!
    deleteManyUsers(input: DeleteManyUsersInput!): DeleteManyResponse!
    deleteOneUser(input: DeleteOneInput!): UserDeleteResponse!
    updateManyUsers(input: UpdateManyUsersInput!): UpdateManyResponse!
    updateOneUser(input: UpdateOneUserInput!): User!
}

type PageInfo {
    "The cursor of the last returned record."
    endCursor: ConnectionCursor
    "true if paging forward and there are more records."
    hasNextPage: Boolean
    "true if paging backwards and there are more records."
    hasPreviousPage: Boolean
    "The cursor of the first returned record."
    startCursor: ConnectionCursor
}

type Query {
    user(
        "The id of the record to find."
        id: ID!
    ): User
    users(
        "Specify to filter the records returned."
        filter: UserFilter = {},
        "Limit or page results."
        paging: CursorPaging = {first : 50000},
        "Specify to sort results."
        sorting: [UserSort!] = []
    ): UserConnection!
}

type UpdateManyResponse {
    "The number of records updated."
    updatedCount: Int!
}

type User {
    created: DateTime!
    firstname: String
    id: String!
    is_admin: Boolean!
    lastname: String
    referral_counter: Float!
    referral_money: Float!
    updated: DateTime!
    username: String
    who_invite: String
}

type UserAvgAggregate {
    referral_counter: Float
    referral_money: Float
}

type UserConnection {
    "Array of edges."
    edges: [UserEdge!]!
    "Paging information"
    pageInfo: PageInfo!
}

type UserCountAggregate {
    firstname: Int
    id: Int
    lastname: Int
    referral_counter: Int
    referral_money: Int
    username: Int
    who_invite: Int
}

type UserDeleteResponse {
    created: DateTime
    firstname: String
    id: String
    is_admin: Boolean
    lastname: String
    referral_counter: Float
    referral_money: Float
    updated: DateTime
    username: String
    who_invite: String
}

type UserEdge {
    "Cursor for this node."
    cursor: ConnectionCursor!
    "The node containing the User"
    node: User!
}

type UserMaxAggregate {
    firstname: String
    id: String
    lastname: String
    referral_counter: Float
    referral_money: Float
    username: String
    who_invite: String
}

type UserMinAggregate {
    firstname: String
    id: String
    lastname: String
    referral_counter: Float
    referral_money: Float
    username: String
    who_invite: String
}

type UserSumAggregate {
    referral_counter: Float
    referral_money: Float
}

"Sort Directions"
enum SortDirection {
    ASC
    DESC
}

"Sort Nulls Options"
enum SortNulls {
    NULLS_FIRST
    NULLS_LAST
}

enum UserSortFields {
    firstname
    id
    lastname
    referral_counter
    referral_money
    username
    who_invite
}

input CreateManyUsersInput {
    "Array of records to create"
    users: [UserCreate!]!
}

input CreateOneUserInput {
    "The record to create"
    user: UserCreate!
}

input CursorPaging {
    "Paginate after opaque cursor"
    after: ConnectionCursor
    "Paginate before opaque cursor"
    before: ConnectionCursor
    "Paginate first"
    first: Int
    "Paginate last"
    last: Int
}

input DeleteManyUsersInput {
    "Filter to find records to delete"
    filter: UserDeleteFilter!
}

input DeleteOneInput {
    "The id of the record to delete."
    id: ID!
}

input NumberFieldComparison {
    between: NumberFieldComparisonBetween
    eq: Float
    gt: Float
    gte: Float
    in: [Float!]
    is: Boolean
    isNot: Boolean
    lt: Float
    lte: Float
    neq: Float
    notBetween: NumberFieldComparisonBetween
    notIn: [Float!]
}

input NumberFieldComparisonBetween {
    lower: Float!
    upper: Float!
}

input StringFieldComparison {
    eq: String
    gt: String
    gte: String
    iLike: String
    in: [String!]
    is: Boolean
    isNot: Boolean
    like: String
    lt: String
    lte: String
    neq: String
    notILike: String
    notIn: [String!]
    notLike: String
}

input UpdateManyUsersInput {
    "Filter used to find fields to update"
    filter: UserUpdateFilter!
    "The update to apply to all records found using the filter"
    update: UserUpdate!
}

input UpdateOneUserInput {
    "The id of the record to update"
    id: ID!
    "The update to apply."
    update: UserUpdate!
}

input UserCreate {
    firstname: String
    id: String!
    lastname: String
    username: String
    who_invite: String
}

input UserDeleteFilter {
    and: [UserDeleteFilter!]
    firstname: StringFieldComparison
    id: StringFieldComparison
    lastname: StringFieldComparison
    or: [UserDeleteFilter!]
    referral_counter: NumberFieldComparison
    referral_money: NumberFieldComparison
    username: StringFieldComparison
    who_invite: StringFieldComparison
}

input UserFilter {
    and: [UserFilter!]
    firstname: StringFieldComparison
    id: StringFieldComparison
    lastname: StringFieldComparison
    or: [UserFilter!]
    referral_counter: NumberFieldComparison
    referral_money: NumberFieldComparison
    username: StringFieldComparison
    who_invite: StringFieldComparison
}

input UserSort {
    direction: SortDirection!
    field: UserSortFields!
    nulls: SortNulls
}

input UserUpdate {
    firstname: String
    lastname: String
    referral_counter: Float
    referral_money: Float
    username: String
}

input UserUpdateFilter {
    and: [UserUpdateFilter!]
    firstname: StringFieldComparison
    id: StringFieldComparison
    lastname: StringFieldComparison
    or: [UserUpdateFilter!]
    referral_counter: NumberFieldComparison
    referral_money: NumberFieldComparison
    username: StringFieldComparison
    who_invite: StringFieldComparison
}


"A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format."
scalar DateTime

"Cursor for paging through collections"
scalar ConnectionCursor
